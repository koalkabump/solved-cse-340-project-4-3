Download Link: https://assignmentchef.com/product/solved-cse-340-project-4-3
<br>
<strong>Abstract</strong>

The goal of this project is to give you some hands-on experience with implementing a small compiler. You will write a compiler for a simple language. You will not be generating assembly code. Instead, you will generate an intermediate representation (a data structure that represents the program). The execution of the program will be done after compilation by <em>interpreting </em>the generated intermediate representation.

<h1>1           Introduction</h1>

You will write a small compiler that will read an input program and represent it in an internal data structure. The data structure consists of two parts: (1) a representation of instructions to be executed and (2) a representation of the memory of the program (locations for variables). Instructions are represented by a data structure that includes the operand(s) of the instruction (if any) and that specify the next instruction to be executed. After the data structures are generated by your compiler, your compiler will <em>execute </em>the generated instructions representation by interpreting it. This means that the program will traverse the data structure and at every node it visits, it will execute the node by changing the content of memory locations corresponding to operands and deciding what is the next instruction to execute (program counter). The output of your compiler is the output that the input program should produce. These steps are illustrated in the following figure

The remainder of this document is organized as follows:

<ol>

 <li><strong>Grammar </strong>Defines the programming language syntax including grammar.</li>

 <li><strong>Execution Semantics </strong>Describe statement semantics for if, while, switch and print</li>

 <li><strong>How to generate the intermediate representation </strong>Explains step by step how to generate the intermediate representation (data structure). <strong>You should read this sequentially and not skip around.</strong></li>

 <li><strong>Executing the intermediate representation </strong>Basically, you have two options: (1) If you are using C/C++, you should use the code we provide to execute the intermediate representation; (2) If you are using Java, this section describes the strict rules to follow in executing the intermediate representation. Those rules will be enforced by inspecting your code.</li>

 <li><strong>Requirements </strong>Lists the programming languages you are allowed to use in your solution (C/C++ or Java) and other requirements.</li>

 <li><strong>Grading </strong>Describes the grading scheme.</li>

 <li><strong>Second Chance Project </strong>Describes the requirements for a bonus project.</li>

</ol>

<h1>2           Grammar</h1>

The grammar for this project is a simplified form of the grammar from the previous project, but there are a couple extensions.

<table width="588">

 <tbody>

  <tr>

   <td width="91"><em>program</em></td>

   <td width="35">→</td>

   <td width="246"><em>var </em><em>section   body</em></td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>var section</em></td>

   <td width="35">→</td>

   <td width="246"><em>id </em><em>list </em>SEMICOLON</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>id </em><em>list</em></td>

   <td width="35">→</td>

   <td width="246">ID COMMA            <em>id </em><em>list </em>| ID</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>body</em></td>

   <td width="35">→</td>

   <td width="246">LBRACE         <em>stmt </em><em>list </em>RBRACE</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>stmt list</em></td>

   <td width="35">→</td>

   <td width="246"><em>stmt       stmt list </em>| stmt</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>stmt</em></td>

   <td width="35">→</td>

   <td width="246"><em>assign </em><em>stmt </em>| <em>print stmt </em>| <em>while stmt</em></td>

   <td width="15">|</td>

   <td width="49"><em>if </em><em>stmt</em></td>

   <td width="15">|</td>

   <td width="77"><em>switch </em><em>stmt</em></td>

   <td colspan="2" width="15">|</td>

   <td width="46"><em>for stmt</em></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>assign stmt</em></td>

   <td width="35">→</td>

   <td width="246">ID EQUAL             <em>primary </em>SEMICOLON</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>assign stmt</em></td>

   <td width="35">→</td>

   <td width="246">ID EQUAL             <em>expr </em>SEMICOLON</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>expr</em></td>

   <td width="35">→</td>

   <td width="246"><em>primary    op    primary</em></td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>primary</em></td>

   <td width="35">→</td>

   <td width="246">ID | NUM</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>op</em></td>

   <td width="35">→</td>

   <td width="246">PLUS | MINUS | MULT | DIV</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>print stmt while stmt</em></td>

   <td width="35">→→</td>

   <td width="246"><strong>print </strong>ID SEMICOLONWHILE <em>condition        body</em></td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>if stmt</em></td>

   <td width="35">→</td>

   <td width="246">IF <em>condition       body</em></td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>condition</em></td>

   <td width="35">→</td>

   <td width="246"><em>primary    relop    primary</em></td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>relop</em></td>

   <td width="35">→</td>

   <td width="246">GREATER | LESS | NOTEQUAL</td>

   <td width="15"></td>

   <td width="49"></td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>switch stmt</em></td>

   <td width="35">→</td>

   <td colspan="3" width="310">SWITCH ID                LBRACE <em>case list </em>RBRACE</td>

   <td width="15"></td>

   <td width="77"></td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>switch stmt</em></td>

   <td width="35">→</td>

   <td colspan="5" width="401">SWITCH ID            LBRACE <em>case list          default case </em>RBRACE</td>

   <td colspan="2" width="15"></td>

   <td width="46"></td>

   <td colspan="2" width="34"></td>

  </tr>

  <tr>

   <td width="91"><em>for </em><em>stmt</em></td>

   <td width="35">→</td>

   <td colspan="6" width="404">FOR LPAREN assign stmt condition SEMICOLON assign stmt</td>

   <td colspan="3" width="68">RPAREN</td>

   <td width="25"><em>body</em></td>

  </tr>

  <tr>

   <td width="91"><em>case list</em></td>

   <td width="35">→</td>

   <td colspan="6" width="404"><em>case      case </em><em>list </em>| <em>case</em></td>

   <td colspan="3" width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>case</em></td>

   <td width="35">→</td>

   <td colspan="6" width="404">CASE NUM            COLON <em>body</em></td>

   <td colspan="3" width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>default </em><em>case</em></td>

   <td width="35">→</td>

   <td colspan="6" width="404">DEFAULT COLON           <em>body</em></td>

   <td colspan="3" width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="88"></td>

   <td width="32"></td>

   <td width="227"></td>

   <td width="14"></td>

   <td width="47"></td>

   <td width="14"></td>

   <td width="72"></td>

   <td width="3"></td>

   <td width="11"></td>

   <td width="46"></td>

   <td width="9"></td>

   <td width="27"></td>

  </tr>

 </tbody>

</table>

<strong>Some highlights of the grammar:</strong>

<ol>

 <li>Expressions are greatly simplified and are not recursive.</li>

 <li>There is no type declaration section.</li>

 <li>Division is integer division and the result of the division of two integers is an integer.</li>

 <li><em>if </em>statement is introduced. Note that <em>if stmt </em>does not have <em>else</em>.</li>

 <li><em>for </em>statement is introduced. Note that <em>for </em>has a very general syntax similar to that of the C language for loop.</li>

 <li>A <em>print </em>statement is introduced. Note that the <strong>print </strong>keyword is in lower case, but other keywords are all upper-case letters.</li>

 <li>There is no variable declaration list. There is only one <em>id list </em>in the global scope and that contains all the variables.</li>

 <li>There is no type specified for variables. All variables are int by default.</li>

</ol>

<h1>3           Execution Semantics</h1>

All statements in a statement list are executed sequentially according to the order in which they appear. Exception is made for body of <em>if stmt</em>, <em>while </em><em>stmt </em>and <em>switch </em><em>stmt </em>as explained below. In what follows, I will assume that all values of variables as well as constants are stored in locations. This assumption is used by the execution procedure that we provide. This is not a restrictive assumption. For variables, you will have locations associated with them. For constants, you can reserve a location in which you store the constant (this is like having an unnamed immutable variable).

<h2>3.1         Assignment Statement</h2>

To execute an assignment statement, the expression on the lefthand side of the equal sign is evaluated and the result is stored in the location associated with the righthand side of the expression.

<h2>3.2         Expression</h2>

To evaluate an expression, the values in the locations associated with the two operands are obtained and the expression operator is applied to these values resulting in a value for the expression.

<h2>3.3         Boolean Condition</h2>

A boolean condition takes two operands as parameters and returns a boolean value. It is used to control the execution of <em>while </em>and <em>if </em>statements. To evaluate a condition, the values in the locations associated with the operands are obtained and the relational operator is applied to these values resulting in a true or false value. For example, if the values of the two operands a and b are 3 and 4 respectively, a &lt; b evaluates to <strong>true</strong>.

<h2>3.4         <em>If </em>statement</h2>

<em>if </em><em>stmt </em>has the standard semantics:

<ol>

 <li>The condition is evaluated.</li>

 <li>If the condition evaluates to <strong>true</strong>, the body of the <em>if </em><em>stmt </em>is executed, then the next statement (if any) following the <em>if </em><em>stmt </em>in the <em>stmt </em><em>list </em>is executed.</li>

 <li>If the condition evaluates to <strong>false</strong>, the statement following the <em>if stmt </em>in the <em>stmt </em><em>list </em>is executed</li>

</ol>

These semantics apply recursively to nested <em>if </em><em>stmt</em>.

<h2>3.5         <em>While </em>statement</h2>

<em>while </em><em>stmt </em>has the standard semantics.

<ol>

 <li>The condition is evaluated.</li>

 <li>If the condition evaluates to <strong>true</strong>, the body of the <em>while </em><em>stmt </em>is executed. The next statement to execute is the <em>while stmt </em></li>

 <li>If the condition evaluates to <strong>false</strong>, the body of the <em>while </em><em>stmt </em>is not executed. The next statement to execute is the next statement (if any) following the <em>while stmt </em>in the <em>stmt list</em>.</li>

</ol>

These semantics apply recursively to nested <em>while stmt</em>. The code block:

<table width="594">

 <tbody>

  <tr>

   <td width="594">WHILE <em>condition</em>{ <em>stmt list</em>}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594"><em>label</em>: IF <em>condition</em>{ <em>stmt list </em><strong>goto </strong><em>label</em>}</td>

  </tr>

 </tbody>

</table>

Note that <strong>goto </strong>statements do not appear in the input program, but our intermediate representation includes GotoStatement which is used in conjunction with IfStatement to represent <em>while </em>and <em>switch </em>statements.

<h2>3.6         <em>For </em>statement</h2>

The <em>for stmt </em>is very similar to the for statement in the C language. The semantics are defined by giving an equivalent construct.

<table width="594">

 <tbody>

  <tr>

   <td width="594">FOR ( <em>assign stmt 1 condition </em>; <em>assign stmt 2 </em>){ <em>stmt list</em>}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<em>assign stmt 1</em>

WHILE <em>condition</em>

{

<em>stmt list assign stmt 2 </em>}

For example, the following snippet of code:

<table width="594">

 <tbody>

  <tr>

   <td width="594">FOR ( a = 0; a &lt; 10; a = a + 1; ){ print a;}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594">a = 0;WHILE a &lt; 10{ print a;a = a + 1;}</td>

  </tr>

 </tbody>

</table>

<h2>3.7         <em>Switch </em>statement</h2>

<em>switch stmt </em>has the following semantics<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a>:

<ol>

 <li>The value of the switch variable is checked against each case number in order.</li>

 <li>If the value matches the number, the body of the case is executed, then the statement following the <em>switch </em><em>stmt </em>in the <em>stmt list </em>is executed.</li>

 <li>If the value does not match the number, next case is evaluated.</li>

 <li>If a default case is provided and the value does not match any of the case numbers, then the body of the default case is executed and then the statement following the <em>switch stmt </em>in the <em>stmt </em><em>list </em>is executed.</li>

 <li>If there is no default case and the value does not match any of the case numbers, then the statement following the <em>switch </em><em>stmt </em>in the <em>stmt list </em>is executed. These semantics apply recursively to nested <em>switch stmt</em>. The code block:</li>

</ol>

<table width="594">

 <tbody>

  <tr>

   <td width="594">SWITCH <em>var </em>{CASE <em>n</em><sub>1 </sub>: { <em>stmt list 1 </em>}…CASE <em>n<sub>k </sub></em>: { <em>stmt list </em><em>k </em>}}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594">IF <em>var </em>== <em>n</em><sub>1 </sub>{<em>stmt list </em><em>1 </em><strong>goto </strong><em>label</em>}…IF <em>var </em>== <em>n<sub>k </sub></em>{<em>stmt list </em><em>k </em><strong>goto </strong><em>label</em>}<em>label</em>:</td>

  </tr>

 </tbody>

</table>

And for switch statements with default case, the code block:

<table width="594">

 <tbody>

  <tr>

   <td width="594">SWITCH <em>var </em>{CASE <em>n</em><sub>1 </sub>: { <em>stmt list 1 </em>}…CASE <em>n<sub>k </sub></em>: { <em>stmt list </em><em>k </em>}DEFAULT : { <em>stmt list default </em>}}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594">IF <em>var </em>== <em>n</em><sub>1 </sub>{<em>stmt list </em><em>1 </em><strong>goto </strong><em>label</em>}…IF <em>var </em>== <em>n<sub>k </sub></em>{<em>stmt list </em><em>k </em><strong>goto </strong><em>label</em>}<em>stmt list default</em><em>label</em>:</td>

  </tr>

 </tbody>

</table>

<h2>3.8         <em>Print </em>statement</h2>

The statement print a; prints the value of variable a at the time of the execution of the <em>print </em>statement.

<h1>4           How to generate the code</h1>

The intermediate code will be a data structure (a graph) that is easy to interpret and execute. I will start by describing how this graph looks for simple assignments then I will explain how to deal with <em>while </em>statements.

<strong>Note that in the explanation below I start with incomplete data structures then I explain what is missing and make them more complete. You should read the whole explanation.</strong>

<h2>4.1         Handling simple assignments</h2>

A simple assignment is fully determined by: the operator (if any), the id on the left-hand side, and the operand(s). A simple assignment can be represented as a node:

struct AssignmentStatement { struct ValueNode* left_hand_side; struct ValueNode* operand1; struct ValueNode* operand2;

ArithmeticOperatorType op; // operator }

For assignment without an expression on the right-hand side, the operator is set to OPERATOR NONE and there is only one operand. To execute an assignment, you need the values of the operand(s), apply the operator, if any, to the operands and assign the resulting value of the right-hand side to the left hand side. For literals (NUM), the value is the value of the number. For variables, the value is the last value stored in the location associated with the variable. <strong>Initially, all variables are initialized to 0</strong>. In this representation, the locations associated with variables as well as the locations in which constants are stored are value nodes ( struct valueNode), a node that contains a value. The assignment statement contains pointers to the value nodes of the left-hand side and the operand(s).

Multiple assignments are executed one after another. So, we need to allow multiple assignment nodes to be linked to each other. This can be achieved as follows:

struct AssignmentStatement { struct ValueNode* left_hand_side; struct ValueNode* operand1; struct ValueNode* operand2;

ArithmeticOperatorType op; // operator struct AssignmentStatement* next;

}

This structure only accepts ValueNode as operands. To handle literal constants (NUM), you need to create ValueNode for them and initialize the value stored in these value nodes to the constant value. This initialization, as well as the initialization of values in locations associated with variable is done while parsing.

This will now allow us to execute a sequence of assignment statements represented in a linkedlist: we start with the head of the list, then we execute every assignment in the list one after the other.

<strong>Begin Note </strong>It is important to distinguish between compile-time initialization and runtime execution. For example, consider the program

a b;

{

a = 3; b = 5;

}

The intermediate representation for this program will have have two assignment statements: one to copy the value in the location that contains the value 3 to the location associated with a and one to copy the value in the location that contains the value 5 to the location associated with b. The values 3 and 5 will not be copied to the locations of a and b at compile-time. The values 3 and 5 will be copied during execution by the interpreter that we provided (for C/C++) or that you will write (for Java)<strong>End Note</strong>

This is simple enough, but does not help with executing other kinds of statements. We consider them one at a time.

<h2>4.2         Handling <em>print </em>statements</h2>

The <em>print </em>statement is straightforward. It can be represented as

struct PrintStatement

{ struct ValueNode* id;

}

Now, we ask: how can we execute a sequence of statements that are either assignment or print statement (or other types of statements)? We need to put both kinds of statements in a list and not just the assignment statements as we did above. So, we introduce a new kind of node: a statement node. The statement node has a field that indicates which type of statement it is. It also has fields to accommodate the remaining types of statements. It looks like this:

struct StatementNode {

StatementType type; // NOOP_STMT, GOTO_STMT, ASSIGN_STMT, IF_STMT, PRINT_STMT

union { struct AssignmentStatement* assign_stmt; struct PrintStatement* print_stmt; struct IfStatement* if_stmt; struct GotoStatement* goto_stmt;

}; struct StatementNode* next;

}

This way we can go through a list of statements and execute one after the other. To execute a particular node, we check its type. If the type is PRINT STMT, we execute the print stmt field, if the type is ASSIGN STMT, we execute the assign stmt field and so on. With this modification, we do not need a next field in the AssignmentStatement structure (as we explained above), instead, we put the next field in the statement node.

This is all fine, but we do not yet know how to generate the list to execute later. The idea is to have the functions that parses non-terminals return the code that corresponds to the non-terminals.

For example for a statement list, we have the following pseudecode (missing many checks):

struct StatementNode* parse_stmt_list()

{ struct StatementNode* st; // statement struct StatementNode* stl; // statement list

st = parse_stmt(); if (nextToken == start of a statement list)

{ stl = parse_stmt_list();

append stl to st;     // this is pseudecode return st;

} else { ungetToken(); return st;

}

}

And to parse <em>body </em>we have the following pseudecode:

struct StatementNode* parse_body()

{ struct StatementNode* stl;

match LBRACE stl = parse_stmt_list(); match RBRACE

return stl;

}

<h2>4.3         Handling <em>if </em>and <em>while </em>statements</h2>

More complications occur with <em>if </em>and <em>while </em>statements. The structure for an <em>if </em>statement can be as follows:

struct IfStatement {

ConditionalOperatorType condition_op; struct ValueNode* condition_operand1; struct ValueNode* condition_operand2;

struct StatementNode* true_branch; struct StatementNode* false_branch;

}

The condition op, condition operand1 and condition operand2 fields are the operator and operands of the condition of the <em>if </em>statement. To generate the node for an <em>if </em>statement, we need to put together the <em>condition</em>, and <em>stmt list </em>that are generated in the parsing of the <em>if </em>statement.

The true branch and false branch fields are crucial to the execution of the <em>if </em>statement. If the condition evaluates to true then the statement specified in true branch is executed otherwise the one specified in false branch is executed. We need one more type of node to allow loop back for <em>while </em>statements. This is a GotoStatement.

struct GotoStatement { struct StatementNode* target;

}

To generate code for the <em>while </em>and <em>if </em>statements, we need to put a few things together. The outline given above for <em>stmt </em><em>list </em>needs to be modified as follows (this is missing details and shows only the main steps).

struct StatementNode* parse_stmt()

{ …

create statement node st if next token is IF

{ st-&gt;type = IF_STMT;

create if-node;                                                                                                          // note that if-node is pseudecode and is not

// a valid identifier in C, C++ or Java

st-&gt;if_stmt = if-node;

parse the condition and set if-node-&gt;condition_op, if-node-&gt;condition_operand1 and if-node-&gt;condition_operand2

if-node-&gt;true_branch = parse_body();                                                              // parse_body returns a pointer to a list of statements

create no-op node                                                                                                    // this is a node that does not result

// in any action being taken

append no-op node to the body of the if                                                      // this requires a loop to get to the end of

// if-node-&gt;true_branch by following the next field

// you know you reached the end when next is NULL

// it is very important that you always appropriately

// initialize fields of any data structures // do not use uninitialized pointers

set if-node-&gt;false_branch to point to no-op node set st-&gt;next to point to no-op node …

} else …

}

The following diagram shows the desired structure for the <em>if </em>statement:

The <em>stmt list </em>code should be modified because of the extra no-op node:

struct StatementNode* parse_stmt_list()

{ struct StatementNode* st; // statement struct StatementNode* stl; // statement list

st = parse_stmt(); if (nextToken == start of a statement list)

{ stl = parse_stmt_list();

if st-&gt;type == IF_STMT

{ append stl to the no-op node that follows st

//                  st

//                  |

//                 V

//              no-op

//                  |

//                 V

//                 stl

} else { append stl to st;

//                  st

//                  |

//                 V

//                 stl

} return st;

} else { ungetToken(); return st;

}

}

Handling <em>while </em>statement is similar. Here is the outline for parsing a <em>while </em>statement and creating the data structure for it:

…

create statement node st if next token is WHILE

{

<table width="445">

 <tbody>

  <tr>

   <td width="242">st-&gt;type = IF_STMT;</td>

   <td width="203">// handling WHILE using if and goto nodes</td>

  </tr>

  <tr>

   <td width="242">create if-node</td>

   <td width="203">// if-node is not a valid identifier see// corresponding comment above</td>

  </tr>

 </tbody>

</table>

st-&gt;if_stmt = if-node parse the condition and set if-node-&gt;condition_op, if-node-&gt;condition_operand1 and if-node-&gt;condition_operand2 if-node-&gt;true_branch = parse_body();

<table width="420">

 <tbody>

  <tr>

   <td width="242">create a new statement node gt gt-&gt;type = GOTO_STMT;</td>

   <td width="178">// This is of type StatementNode</td>

  </tr>

  <tr>

   <td width="242">create goto-node gt-&gt;goto_stmt = goto-node;</td>

   <td width="178">// This is of type GotoStatement</td>

  </tr>

  <tr>

   <td width="242">goto-node-&gt;target = st;</td>

   <td width="178">// to jump to the if statement after// executing the body</td>

  </tr>

 </tbody>

</table>

append gt to the body of the while                                                         // append gt to the body of the while

// this requires a loop. check the comment // for the if above.

create no-op node set if-node-&gt;false_branch to point to no-op node set st-&gt;next to point to no-op node

} …

The following diagram shows the desired structure for the <em>while </em>statement:

<h2>4.4         Handling <em>switch </em>and <em>for </em>statements</h2>

You can handle the <em>switch </em>and <em>for </em>statements similarly, but you should figure that yourself. Use a combination of IfStatement and GotoStatement to support the semantics of the <em>switch </em>and <em>for </em>statements. See sections 3.7 and 3.6 for the semantics of the <em>switch </em>and <em>for </em>statements.

<h1>5           Executing the intermediate representation</h1>

After the graph data structure is built, it needs to be executed. Execution starts with the first node in the list. Depending on the type of the node, the next node to execute is determined. The general form for execution is illustrated in the following pseudo-code.

pc = first node while (pc != NULL)

{ switch (pc-&gt;type)

{ case ASSIGN_STMT: // code to execute pc-&gt;assign_stmt …

pc = pc-&gt;next

case IF_STMT:                   // code to evaluate condition …

// depending on the result

//           pc = pc-&gt;if_stmt-&gt;true_branch

// or

//           pc = pc-&gt;if_stmt-&gt;false_branch

case NOOP_STMT: pc = pc-&gt;next

case GOTO_STMT: pc = pc-&gt;goto_stmt-&gt;target

case PRINT_STMT: // code to execute pc-&gt;print_stmt …

pc = pc-&gt;next

}

}

<strong>C/C++ implementations              </strong>If you are developing in C/C++, we have provided you with the data

structures and the code to execute the graph and <strong>you must use it</strong>. There are two files compiler.h and compiler.cc, you need to write your code in separate file(s) and #includecompiler.h. The

entry point of your code is a function declared in compiler.h: struct StatementNode* parse_generate_intermediate_representation();

You need to implement this function. The main() function is provided in compiler.cc:

int main()

{ struct StatementNode * program;

program = parse_generate_intermediate_representation(); execute_program(program); return 0;

}

It calls the function that you will implement which is supposed to parse the program and generate the intermediate representation, then it calls the execute program function to execute the program. You should not modify any of the given code. In fact if you write your program in C/C++, you should only submit the file(s) that contain your own code and we will add the given part and compile the code before testing. If you write your program in Java, you should strictly follow the guidelines for executing the intermediate representation.

<strong>JAVA Implementation: If you write your solution in Java, executing the graph should be done non-recursively and without any function calls. Even helper functions are not allowed for the execution of the graph. This is a requirement that will be checked by inspecting your code. Little credit will be assigned if this requirement is not met.</strong>

<h1>6           Requirements</h1>

<ol>

 <li>Write a compiler that generates intermediate representation for the code and write an interpreter to execute the intermediate representation. The interpreter is provided for C/C++ implementations.</li>

 <li><strong>Language: </strong>You can use Java, C, or C++ for this assignment.</li>

 <li><strong>Any language other than Java, C or C++ is not allowed for this project</strong>.</li>

 <li>If you use C/C++ for this project, you should use the provided code and only implement the required functions.</li>

 <li>If you use Java, you will need to write everything yourself but the requirements on how to execute the intermediate representation will be checked manually when grading.</li>

 <li><strong>Platform: </strong>As previous projects, the reference platform is CentOS 6.7</li>

 <li><strong>You can assume that there are no syntax or semantic errors in the input program.</strong></li>

</ol>

<h1>7           Grading</h1>

The test cases provided with the assignment, do not contain any test case for <em>switch </em>and <em>for </em>statements. However, test cases with <em>switch </em>and <em>for </em>statements will be added for grading the project. Make sure you test your code extensively with input programs that contain <em>switch </em>and <em>for </em>statements.

The test cases (there will be multiple test cases in each category, each with equal weight) will be broken down in the following way (out of 100 points):

<ul>

 <li>Assignment statements: 20</li>

 <li>If statements: 25</li>

 <li>While statements: 30</li>

 <li>Switch: 15</li>

 <li>All statements not including For statement: 10</li>

 <li>For statement: 5 (bonus)</li>

 <li><strong>Total: </strong>105</li>

</ul>

Note that all test cases depend on successful implementation of print statements (otherwise your program cannot generate correct output). Also, assignment statements are needed for <em>if</em>, <em>while</em>, <em>switch</em>, statement test cases all depend on assignment statements.


